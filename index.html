
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <title>PoKi Puzzle</title>
  <style>
    :root{
      --cream:#F4EFE9;--paper:#FAF7F2;--ink:#141414;--muted:#6f6f6f;
      --accent: #AC9377;--accent-dark: #AC9377;--line:rgba(0,0,0,0.10);
      --radius:14px;--shadow:0 10px 30px rgba(0,0,0,0.08)
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;background:var(--cream);color:var(--ink);
      font-family: Inter, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display:block;padding:0
    }
    .app{width:100%;max-width:none;display:grid;grid-template-columns:1fr;gap:12px;position:relative}
    .card{background:#fff;border:1px solid var(--line);border-radius:0;box-shadow:none;overflow:hidden;position:relative}
    .header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--line);background:var(--paper)}
    .brand{display:flex;align-items:center;gap:10px;font-weight:700}
    .brand img.logo{height:22px;width:auto;display:block}
    .pill{border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:#fff;font-size:12px;color:#777;white-space:nowrap}
    .panel{padding:10px 12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .stat{background:var(--paper);border:1px solid var(--line);padding:8px 10px;border-radius:12px;min-width:100px;text-align:center}
    .stat small{display:block;color:var(--muted);font-size:12px;margin-bottom:2px}
    .stat b{font-size:16px;font-weight:700}
    .btn,.btn:link,.btn:visited{
      appearance:none;-webkit-appearance:none;border:1px solid var(--line);
      background:var(--paper);color:var(--ink);padding:9px 12px;border-radius:12px;
      font-weight:700;cursor:pointer;text-decoration:none;display:inline-block;font-family:inherit;letter-spacing:.2px;line-height:1.1
    }
    .btn:hover{background:#fff;border-color:rgba(0,0,0,0.18)}
    .btn.primary{background:var(--accent);color:#fff;border-color:var(--accent-dark)}
    .btn.primary:hover{background:var(--accent-dark)}
    .btn.danger{background:#fff0ee;border-color:rgba(230,83,60,0.35);color:#9b2a1a}
    .btn.toggle.active{outline:2px solid rgba(230,83,60,0.35)}
    .wrap{padding:12px}
    .board{position:relative;border-radius:12px;background:var(--paper);height:calc(100vh - 210px)}
    #canvas{display:block;width:100%;height:100%;border-radius:12px}
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,0.98);z-index:10;overflow:hidden}
    .overlay .menu{position:relative;z-index:2;background:#fff;border:1px solid var(--line);border-radius:18px;box-shadow:var(--shadow);padding:24px;min-width:320px;max-width:min(92vw,460px);width:100%;text-align:center}
    .menu .v{display:flex;flex-direction:column;gap:10px}
    #menuBG{position:absolute;inset:0;z-index:1;pointer-events:none;opacity:.9}
    #lbList{max-height:50vh;overflow:auto;text-align:left}
    .lbrow{display:grid;grid-template-columns:32px 1fr 90px 70px;gap:10px;padding:8px 0;border-bottom:1px solid rgba(0,0,0,.06)}
    .lbrow b{font-weight:700}
    .inline{display:flex;gap:8px;justify-content:center;align-items:center}
    input[type="text"]{border:1px solid var(--line);border-radius:10px;padding:10px 12px;font:inherit;width:100%}
    .nameGate{display:none !important;gap:8px;margin-top:6px}
    @media (max-width:640px){
      .panel{flex-direction:column;align-items:stretch}
      .stat{width:100%}
      .panel 
      .menu .v 
      .lbrow{grid-template-columns:28px 1fr 80px 60px}
    }
  
/* Shorter menu buttons on desktop */
@media (min-width: 641px){
  .overlay .menu .v{align-items:center}
  .overlay .menu .v .btn{width:auto; min-width: 220px; max-width: 320px; padding:10px 16px}
}


/* FX canvas above everything */
#fxCanvas{position:fixed; inset:0; pointer-events:none; z-index:60}
/* Win overlay above normal overlays */
#winOverlay{z-index:50}


/* Hide game UI when main menu is open */
body.is-menu .panel, body.is-menu .board { display:none !important; }

</style>

<style id="patch_menu_final_v16_css">
/* Ensure the menu overlay covers the viewport and is transparent in menu */
#menuOverlay{ position:fixed !important; inset:0 !important; }
body.is-menu #menuOverlay{ background: transparent !important; }
/* Keep background canvas properly layered under the menu card */
#menuBG{ position:absolute !important; inset:0 !important; z-index:1 !important; pointer-events:none !important; opacity:0.95; }
#menuOverlay .menu{ position:relative !important; z-index:2 !important; }
/* Never show confetti canvas in menu */
body.is-menu #fxCanvas{ display:none !important; }
</style>


<style id="follow_dock_css_right">
  .followDock{
    position:fixed; right:14px; bottom:14px; z-index:1000;
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    justify-content:flex-end;
  }
  .btn.follow-sm{ padding:6px 9px; border-radius:9px; font-weight:700; }
  body.is-menu .followDock{ z-index: 2000; }
</style>


<style id="sentient_magic">
  /* Keep original variables/colors - add effects only */
  .btn{
    position:relative; overflow:hidden;
    transition: transform .15s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;
    box-shadow: 0 6px 16px rgba(0,0,0,0.12);
  }
  .btn:hover{ transform: translateY(-1px); }
  .btn.primary{
    /* keep var(--accent) background; add gentle gradient in same hue */
    background: linear-gradient(180deg, var(--accent) 0%, var(--accent-dark) 100%);
    color:#fff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.05) inset, 0 10px 24px rgba(230,83,60,0.25);
  }
  .btn.primary:hover{
    box-shadow: 0 0 0 1px rgba(0,0,0,0.05) inset, 0 14px 34px rgba(230,83,60,0.35);
  }
  .btn::after{
    content:""; position:absolute; inset:-1px; pointer-events:none;
    background: radial-gradient(120px 40px at var(--mx,50%) -20%, rgba(255,255,255,0.35), rgba(255,255,255,0) 60%);
    transition: opacity .2s ease;
    opacity:.0;
  }
  .btn:hover::after{ opacity:.9; }
  .btn.magicPulse{
    animation: pulseGlow 2.3s ease-in-out infinite;
  }
  @keyframes pulseGlow{
    0%,100%{ box-shadow: 0 6px 16px rgba(0,0,0,0.12), 0 0 0 rgba(230,83,60,0); }
    50%{ box-shadow: 0 6px 16px rgba(0,0,0,0.12), 0 0 24px rgba(230,83,60,0.35); }
  }

  /* Canvas frame glow */
  #canvas{
    border:1px solid var(--line);
    box-shadow: 0 10px 26px rgba(0,0,0,0.14), 0 0 0 1px rgba(0,0,0,0.03) inset, 0 0 28px rgba(230,83,60,0.12);
  }

  /* Stats tiles subtle glow */
  .panel .stat{
    box-shadow: 0 0 0 1px rgba(0,0,0,0.02) inset, 0 6px 18px rgba(0,0,0,0.08);
  }

  /* Follow dock spacing */
  .followDock{ gap:12px; }
</style>


<link rel="icon" type="image/png" href="https://gokite.ai/">
<link rel="apple-touch-icon" href="https://gokite.ai/">


<style id="noscroll-fix">
/* No-scroll layout for gameplay */
html, body { height: 100%; overflow: hidden !important; }
.card{ height:100%; min-height:100%; overflow:visible !important; }
</style>
</head>
<body>
  <div class="app">
    <div class="card" id="card">
      <div class="header">
        <div class="brand">
          <img src="logo.png" alt="Sentient" class="logo" onerror="this.style.display='none'">
        </div>
        <div class="pill">Quiz - 9Ã—9</div>
      </div>
      <div class="panel">
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <div class="stat"><small>Time</small><b id="time">00:00.0</b></div>
          <div class="stat"><small>Moves</small><b id="moves">0</b></div>
          <div class="stat"><small>Status</small><b id="status">Menu</b></div>
        </div>
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <button class="btn" id="menuBtn">Main Menu</button>
          <button class="btn" id="changeNameBtn">Change Name</button>
          <button class="btn primary" id="shuffleBtn">Shuffle</button>
          <button class="btn" id="ghostBtn">Ghost image</button>
          <button class="btn toggle" id="snapBtn">Magnet</button>
          <button class="btn danger" id="resetBtn">Reset</button>
        </div>
      </div>
      <div class="wrap">
        <div class="board"><canvas id="canvas" width="900" height="560" aria-label="Puzzle board"></canvas></div>
</div>
        </div>
      </div>

      <!-- Main menu -->
      <div class="overlay" id="menuOverlay" style="display:flex">
        <canvas id="menuBG"></canvas>
        <div class="menu">
          <h1 style="margin:0 0 12px 0">PoKi Puzzle</h1>
          <div class="v">
            <button class="btn primary" id="startBtn" disabled>Start</button>

            <!-- First-time name gate -->
            <div id="nameGate" class="nameGate">
              <input id="nameInputGate" type="text" placeholder="Enter your name to start" maxlength="20"/>
              <button class="btn" id="saveNameGateBtn" style="white-space:nowrap">Save</button>
            </div>

            <button class="btn" id="leaderBtn">Leaderboard</button>
            <a class="btn" href="https://gokite.ai/" target="_blank" rel="noopener noreferrer">Go Kite AI</a>
            <button class="btn dev" id="devSolveBtn">DEV - Auto-solve</button>
          </div>
        </div>
      </div>


      <!-- FX confetti canvas (fixed on top) -->
      <canvas id="fxCanvas" aria-hidden="true"></canvas>

      <!-- Win/share modal -->
      <div class="overlay" id="winOverlay" style="display:none">
        <div class="menu">
          <h1 style="margin:0 0 12px 0">Great job!</h1>
          <div class="v" style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start">
            <canvas id="shareCanvas" width="800" height="420" style="border:1px solid var(--line);border-radius:12px;max-width:420px;width:100%"></canvas>
            <div class="v" style="min-width:220px">
              <button class="btn primary" id="shareXBtn">Share on X</button>
              <button class="btn" id="downloadShareBtn">Download image</button>
              <button class="btn" id="okBtn">OK</button>
            </div>
          </div>
        </div>
      </div>
    
      <!-- Leaderboard (no name input here) -->
      <div class="overlay" id="leaderOverlay">
        <div class="menu">
          <h1 style="margin:0 0 12px 0">Leaderboard (Top 25)</h1>
          <div id="lbList"></div>
          <div class="v" style="margin-top:10px">
            <button class="btn" id="refreshLbBtn">Refresh</button>
            <button class="btn" id="closeLeaderBtn">Back</button>
            <button class="btn dev" id="devAddBtn">DEV - Add test score</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
// --- Firebase ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, collection, addDoc, serverTimestamp, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyDIW_RyqS7gDaTNd2vDlpnqkfRn6V22jrs",
  authDomain: "poki-puzzle-leaderboard.firebaseapp.com",
  projectId: "poki-puzzle-leaderboard",
  storageBucket: "poki-puzzle-leaderboard.firebasestorage.app",
  messagingSenderId: "63494789491",
  appId: "1:63494789491:web:35b82fb9e3418424588d06"
};

let FB_ENABLED=false, fb={app:null, db:null};
try{ fb.app=initializeApp(firebaseConfig); fb.db=getFirestore(fb.app); FB_ENABLED=true; }catch(e){ console.warn("Firebase:",e); }

// --- Name helpers ---
const nameKey="sj_name"; const getName=()=>localStorage.getItem(nameKey)||""; const setName=n=>localStorage.setItem(nameKey,n||"");

// Save a score
async function saveScore({timeMs,moves,rows,cols}){
  if(!FB_ENABLED) return;
  try{ await addDoc(collection(fb.db,"scores"),{ name:getName()||null,timeMs,moves,rows,cols,createdAt:serverTimestamp() }); }
  catch(e){ console.warn("saveScore",e); }
}
// Load leaderboard
async function loadLeaderboard(){
  const list=document.getElementById('lbList'); list.innerHTML='<div style="color:#6f6f6f">Loading...</div>';
  if(!FB_ENABLED){ list.textContent='Firebase not configured'; return; }
  try{
    const q=query(collection(fb.db,"scores"),orderBy("timeMs","asc"),limit(25));
    const snap=await getDocs(q);
    list.innerHTML='';
    if(snap.empty){ list.textContent='No scores yet.'; return; }
    let i=1; snap.docs.map(d=>d.data()).forEach(s=>{
      const row=document.createElement('div'); row.className='lbrow';
      row.innerHTML=`<div><b>#${i++}</b></div><div>${s.name||'anon'}</div><div>${fmt(s.timeMs||0)}</div><div>${s.moves||0} mv</div>`;
      list.appendChild(row);
    });
  }catch(e){ list.textContent='Failed to load leaderboard'; }
}

// ---- GAME (2x2) ----
const ROWS = 9, COLS = 9; // 81 pieces
const IMAGE_URL='pazzle.png'; const DOBBY_URL='dobby.png';
const CANVAS=document.getElementById('canvas'); const CTX=CANVAS.getContext('2d');
const timeEl=document.getElementById('time'), movesEl=document.getElementById('moves'), statusEl=document.getElementById('status');
const shuffleBtn=document.getElementById('shuffleBtn'), resetBtn=document.getElementById('resetBtn'), ghostBtn=document.getElementById('ghostBtn'), snapBtn=document.getElementById('snapBtn'), menuBtn=document.getElementById('menuBtn');
const menuOverlay=document.getElementById('menuOverlay'), startBtn=document.getElementById('startBtn'), leaderBtn=document.getElementById('leaderBtn'), leaderOverlay=document.getElementById('leaderOverlay'), refreshLbBtn=document.getElementById('refreshLbBtn'), closeLeaderBtn=document.getElementById('closeLeaderBtn');
const nameGate=document.getElementById('nameGate'), nameInputGate=document.getElementById('nameInputGate'), saveNameGateBtn=document.getElementById('saveNameGateBtn');
const menuBG=document.getElementById('menuBG'); const mbgCtx=menuBG.getContext('2d');
// --- Confetti FX ---
const FX=document.getElementById('fxCanvas'); const FXCTX=FX.getContext('2d');
let confetti=[], confettiAnim=false;
function sizeFx(){ const dpr=window.devicePixelRatio||1; FX.width=innerWidth*dpr; FX.height=innerHeight*dpr; FXCTX.setTransform(dpr,0,0,dpr,0,0); }
function confettiBurst(){
  sizeFx();
  const colors=['#ff7a59','#ffd166','#06d6a0','#118ab2','#ef476f','#ffe156','#8ac926','#1982c4'];
  confetti.length=0; const n=140;
  for(let i=0;i<n;i++){
    confetti.push({x:Math.random()*FX.width, y:-20-Math.random()*80, vx:(Math.random()-0.5)*3, vy:2+Math.random()*3, s:6+Math.random()*6, r:Math.random()*Math.PI, vr:(Math.random()-0.5)*0.2, c:colors[i%colors.length], life:0, max:240+Math.random()*120});
  }
  if(!confettiAnim){ confettiAnim=true; requestAnimationFrame(tickConfetti); }
}
function tickConfetti(){
  if(!confettiAnim){ return; }
  const W=FX.width, H=FX.height; FXCTX.clearRect(0,0,W,H);
  for(const p of confetti){
    p.life++; p.x+=p.vx; p.y+=p.vy; p.r+=p.vr;
    FXCTX.save(); FXCTX.translate(p.x,p.y); FXCTX.rotate(p.r);
    FXCTX.fillStyle=p.c; FXCTX.fillRect(-p.s/2,-p.s/2,p.s,p.s);
    FXCTX.restore();
  }
  confetti = confetti.filter(p=>p.life<p.max && p.y<H+40);
  if(confetti.length>0){ requestAnimationFrame(tickConfetti); } else { confettiAnim=false; }
}
window.addEventListener('resize', sizeFx);


let started=false, finished=false, moves=0; let timer=null, startTime=0, elapsed=0; let useMagnet=true, inMenu=true, hasImage=false, ghostOn=false;
snapBtn.classList.add('active');

function fmt(ms){ const t=Math.floor(ms); const s=Math.floor(t/1000); const m=Math.floor(s/60); const sec=s%60; const tenths=Math.floor((t%1000)/100); return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}.${tenths}`; }
function startTimerOnce(){ if(!started && !finished && !inMenu){ started=true; startTime=performance.now(); timer=setInterval(()=>{ elapsed=performance.now()-startTime; timeEl.textContent=fmt(elapsed); }, 60); statusEl.textContent='Playing'; }}
function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }
function resetTimer(){ stopTimer(); started=false; elapsed=0; timeEl.textContent='00:00.0'; }

const img=new Image(); img.src=IMAGE_URL; img.onload=()=>{ hasImage=true; startBtn.disabled=false; try{ buildPieces(); }catch(_){} shuffleBtn.disabled=false; }; img.onerror=()=>{ hasImage=false; startBtn.disabled=true; };
const dobby=new Image(); let dobbyLoaded=false; dobby.src=DOBBY_URL; dobby.onload=()=>{ dobbyLoaded=true; if(inMenu) initMenuBG(); };

let board={x:60,y:40,w:CANVAS.width-120,h:CANVAS.height-100}; let tileW=0,tileH=0;
function resizeBoardToImage(){
  const cw=CANVAS.width-120, ch=CANVAS.height-100;
  const naturalW=img.naturalWidth||900, naturalH=img.naturalHeight||560, aspect=naturalW/naturalH;
  let w=cw, h=Math.round(cw/aspect); if(h>ch){ h=ch; w=Math.round(h*aspect); }
  board={ x:Math.round((CANVAS.width-w)/2), y:Math.round((CANVAS.height-h)/2), w, h };
  tileW=board.w/COLS; tileH=board.h/ROWS;
}

let gid=1; function makeGroup(p){ const g={id:gid++,pieces:[]}; g.pieces.push(p); p.group=g; return g; }
function moveGroup(g,dx,dy){ for(const k of g.pieces){ k.x+=dx; k.y+=dy; } }
function mergeGroups(a,b){ if(a===b) return; for(const k of b.pieces){ k.group=a; a.pieces.push(k);} b.pieces.length=0; }
function allInOneGroup(){ const g0=pieces[0].group; for(let i=1;i<pieces.length;i++){ if(pieces[i].group!==g0) return false;} return true; }

let pieces=[]; const rand=(a,b)=>a+Math.random()*(b-a);
function genEdges(){ const edges=Array.from({length:ROWS},()=>Array.from({length:COLS},()=>({top:0,right:0,bottom:0,left:0}))); for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){ const e=edges[r][c]; if(r===0)e.top=0; else e.top=-edges[r-1][c].bottom; if(c===0)e.left=0; else e.left=-edges[r][c-1].right; if(c===COLS-1)e.right=0; else e.right=Math.random()<0.5?1:-1; if(r===ROWS-1)e.bottom=0; else e.bottom=Math.random()<0.5?1:-1; }} return edges; }
function piecePath(ctx,w,h,tab,e){ const T=tab; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(w*0.33,0); if(e.top!==0){ const dir=e.top, cy=-T*dir; ctx.bezierCurveTo(w*0.38,0,w*0.38,cy,w*0.5,cy); ctx.bezierCurveTo(w*0.62,cy,w*0.62,0,w*0.67,0);} ctx.lineTo(w,0); ctx.lineTo(w,h*0.33); if(e.right!==0){ const dir=e.right, cx=w+T*dir; ctx.bezierCurveTo(w,h*0.38,cx,h*0.38,cx,h*0.5); ctx.bezierCurveTo(cx,h*0.62,w,h*0.62,w,h*0.67);} ctx.lineTo(w,h); ctx.lineTo(w*0.67,h); if(e.bottom!==0){ const dir=e.bottom, cy=h+T*dir; ctx.bezierCurveTo(w*0.62,h,w*0.62,cy,w*0.5,cy); ctx.bezierCurveTo(w*0.38,cy,w*0.38,h,w*0.33,h);} ctx.lineTo(0,h); ctx.lineTo(0,h*0.67); if(e.left!==0){ const dir=e.left, cx=-T*dir; ctx.bezierCurveTo(0,h*0.62,cx,h*0.62,cx,h*0.5); ctx.bezierCurveTo(cx,h*0.38,0,h*0.38,0,h*0.33);} ctx.closePath(); }
function spawnOutsideCenter(bw,bh){ const M=8,GAP=6; let tries=0; while(tries<2000){ const x=Math.round(rand(M,CANVAS.width-bw-M)); const y=Math.round(rand(M,CANVAS.height-bh-M)); const inX = x < (board.x+board.w+GAP) && (x+bw) > (board.x-GAP); const inY = y < (board.y+board.h+GAP) && (y+bh) > (board.y-GAP); if(!(inX&&inY)) return {x,y}; tries++; } return {x:M,y:M}; }
function buildPieces(){ pieces.length=0; resizeBoardToImage(); const tab=Math.min(tileW,tileH)*0.28; const edges=genEdges(); for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){ const bw=Math.ceil(tileW+tab*2), bh=Math.ceil(tileH+tab*2); const off=document.createElement('canvas'); off.width=bw; off.height=bh; const octx=off.getContext('2d'); octx.save(); octx.translate(tab,tab); piecePath(octx,tileW,tileH,tab,edges[r][c]); octx.shadowColor='rgba(0,0,0,0.12)'; octx.shadowBlur=8; octx.shadowOffsetY=2; octx.clip(); const destX=-c*tileW-tab, destY=-r*tileH-tab; octx.drawImage(img,0,0,img.naturalWidth||900,img.naturalHeight||560,destX,destY,board.w+tab*2,board.h+tab*2); octx.restore(); octx.translate(tab,tab); octx.lineWidth=1; octx.strokeStyle='rgba(0,0,0,0.35)'; piecePath(octx,tileW,tileH,tab,edges[r][c]); octx.stroke(); const tx=Math.round(board.x + c*tileW - tab), ty=Math.round(board.y + r*tileH - tab); const spawn=spawnOutsideCenter(bw,bh); const p={r,c,tx,ty,x:spawn.x,y:spawn.y,bw,bh,bmp:off,group:null}; makeGroup(p); pieces.push(p); }} }
function draw(ghost=false){ CTX.clearRect(0,0,CANVAS.width,CANVAS.height); if(ghost&&hasImage){ CTX.globalAlpha=.18; CTX.drawImage(img,0,0,img.naturalWidth||900,img.naturalHeight||560,board.x,board.y,board.w,board.h); CTX.globalAlpha=1; } for(let i=0;i<pieces.length;i++){ const p=pieces[i]; if(p===draggingPiece) continue; CTX.drawImage(p.bmp,p.x,p.y);} if(draggingPiece){ CTX.drawImage(draggingPiece.bmp,draggingPiece.x,draggingPiece.y);} }
function hitPiece(p,x,y){ return x>=p.x && y>=p.y && x<=p.x+p.bw && y<=p.y+p.bh; }
function pieceAt(r,c){ if(r<0||c<0||r>=ROWS||c>=COLS)return null; for(const p of pieces){ if(p.r===r && p.c===c) return p; } return null; }
function tryMagnetizeFrom(p){ if(!useMagnet) return false; const gA=p.group; const th=Math.min(tileW,tileH)*0.34; const ns=[[p.r,p.c-1],[p.r,p.c+1],[p.r-1,p.c],[p.r+1,p.c]]; for(const [nr,nc] of ns){ const q=pieceAt(nr,nc); if(!q||q.group===gA) continue; const offX=(q.tx-p.tx)-(q.x-p.x); const offY=(q.ty-p.ty)-(q.y-p.y); const d=Math.hypot(offX,offY); if(d<th){ moveGroup(q.group,offX,offY); mergeGroups(gA,q.group); if(window.__playSnap) window.__playSnap(); return true; if(window.__playSnap) window.__playSnap(); } } return false; }
let draggingPiece=null, draggingGroup=null, lastPX=0, lastPY=0;
function reorderGroupToTop(g){ const o=[], gm=[]; for(const p of pieces){ (p.group===g?gm:o).push(p); } pieces=o.concat(gm); }
function groupBounds(g){ let minX=1/0,minY=1/0,maxX=-1/0,maxY=-1/0; for(const p of g.pieces){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x+p.bw>maxX)maxX=p.x+p.bw; if(p.y+p.bh>maxY)maxY=p.y+p.bh; } return {minX,minY,maxX,maxY}; }
function clampDeltaToCanvas(g,dx,dy){ const M=6; const b=groupBounds(g); if(b.minX+dx<M) dx=M-b.minX; if(b.minY+dy<M) dy=M-b.minY; if(b.maxX+dx>CANVAS.width-M) dx=(CANVAS.width-M)-b.maxX; if(b.maxY+dy>CANVAS.height-M) dy=(CANVAS.height-M)-b.maxY; return {dx,dy}; }
function pointerDown(x,y){ if(finished||inMenu) return; startTimerOnce(); for(let i=pieces.length-1;i>=0;i--){ const p=pieces[i]; if(hitPiece(p,x,y)){ draggingPiece=p; draggingGroup=p.group; lastPX=x; lastPY=y; reorderGroupToTop(draggingGroup); break; } } }
function pointerMove(x,y){ if(!draggingGroup) return; let dx=x-lastPX, dy=y-lastPY; const c=clampDeltaToCanvas(draggingGroup,dx,dy); dx=c.dx; dy=c.dy; moveGroup(draggingGroup,dx,dy); lastPX+=dx; lastPY+=dy; draw(ghostOn); }
async function pointerUp(x,y){ if(!draggingGroup) return; draggingPiece=null; moves++; movesEl.textContent=moves; let attached=true; while(useMagnet&&attached){ attached=false; const base=[...draggingGroup.pieces]; for(const p of base){ if(tryMagnetizeFrom(p)){ attached=true; break; } } } if(allInOneGroup()){ finished=true; stopTimer(); statusEl.textContent='Solved'; CANVAS.animate([{opacity:1},{opacity:.85},{opacity:1}],{duration:320}); await saveScore({ timeMs:Math.round(elapsed), moves, rows:ROWS, cols:COLS }); } draggingGroup=null; draw(ghostOn); }
CANVAS.addEventListener('mousedown',(e)=>{const r=CANVAS.getBoundingClientRect(); pointerDown(e.clientX-r.left,e.clientY-r.top);});
window.addEventListener('mousemove',(e)=>{const r=CANVAS.getBoundingClientRect(); pointerMove(e.clientX-r.left,e.clientY-r.top);});
window.addEventListener('mouseup',(e)=>{const r=CANVAS.getBoundingClientRect(); pointerUp(e.clientX-r.left,e.clientY-r.top);});
CANVAS.addEventListener('touchstart',(e)=>{const t=e.changedTouches[0],r=CANVAS.getBoundingClientRect(); pointerDown(t.clientX-r.left,t.clientY-r.top); e.preventDefault();},{passive:false});
CANVAS.addEventListener('touchmove',(e)=>{const t=e.changedTouches[0],r=CANVAS.getBoundingClientRect(); pointerMove(t.clientX-r.left,t.clientY-r.top); e.preventDefault();},{passive:false});
CANVAS.addEventListener('touchend',(e)=>{const t=e.changedTouches[0],r=CANVAS.getBoundingClientRect(); pointerUp(t.clientX-r.left,t.clientY-r.top); e.preventDefault();},{passive:false});

ghostBtn.addEventListener('click',()=>{ if(!hasImage) return; ghostOn=!ghostOn; draw(ghostOn); });
snapBtn.addEventListener('click',()=>{ useMagnet=!useMagnet; snapBtn.classList.toggle('active',useMagnet); });
shuffleBtn.addEventListener('click',()=>{ if(!hasImage){ statusEl.textContent='Image not loaded'; return; } buildPieces(); moves=0; movesEl.textContent=0; resetTimer(); finished=false; statusEl.textContent='Ready'; draw(false); });
resetBtn.addEventListener('click',()=>{ if(!hasImage){ statusEl.textContent='Image not loaded'; return; } const g={id:gid++,pieces:[]}; for(const p of pieces){ p.x=p.tx; p.y=p.ty; p.group=g; g.pieces.push(p);} moves=0; movesEl.textContent=0; resetTimer(); finished=false; statusEl.textContent='Ready'; draw(false); });

function openMenu(){ try{ if(typeof confettiAnim!=="undefined") confettiAnim=false; }catch(e){} try{ if(Array.isArray(confetti)) confetti.length=0; }catch(e){} try{ if(typeof FXCTX!=="undefined" && FXCTX && typeof FX!=="undefined"){ FXCTX.clearRect(0,0,FX.width,FX.height);} }catch(e){} inMenu=true; menuOverlay.style.display='flex'; leaderOverlay.style.display='none'; stopTimer(); statusEl.textContent='Menu'; if(dobbyLoaded) initMenuBG(); updateNameGate(); }
function closeMenuAndStart(){ if(!hasImage) return; if(!getName()){ nameInputGate.focus(); return; } inMenu=false; menuOverlay.style.display='none'; leaderOverlay.style.display='none'; shuffleBtn.click(); }
menuBtn.addEventListener('click', openMenu);
startBtn.addEventListener('click', closeMenuAndStart);

// First-time name gate
function updateNameGate(){ const has=getName().trim().length>0; nameGate.style.display = has ? 'none' : 'grid'; startBtn.disabled = !has || !hasImage; }
saveNameGateBtn.addEventListener('click', ()=>{ const v=nameInputGate.value.trim(); if(v){ setName(v); updateNameGate(); } });

leaderBtn.addEventListener('click', async ()=>{ leaderOverlay.style.display='flex'; menuOverlay.style.display='none'; await loadLeaderboard(); });
closeLeaderBtn.addEventListener('click', ()=>{ leaderOverlay.style.display='none'; menuOverlay.style.display='flex'; });
refreshLbBtn.addEventListener('click', loadLeaderboard);

// DEV helpers (?dev=1)
const dev=new URLSearchParams(location.search).get('dev')==='1';
const devAddBtn=document.getElementById('devAddBtn'), devSolveBtn=document.getElementById('devSolveBtn');
if(dev){ devAddBtn.style.display='block'; devSolveBtn.style.display='block';
  devAddBtn.addEventListener('click', async()=>{ const rnd=Math.floor(Math.random()*5000)+1000; await addDoc(collection(fb.db,"scores"),{name:getName()||'dev',timeMs:rnd,moves:Math.floor(Math.random()*12)+3,rows:ROWS,cols:COLS,createdAt:serverTimestamp()}); await loadLeaderboard(); });
  devSolveBtn.addEventListener('click', async()=>{ inMenu=false; menuOverlay.style.display='none'; buildPieces(); const g={id:999,pieces:[]}; for(const p of pieces){ p.x=p.tx; p.y=p.ty; p.group=g; g.pieces.push(p); } draw(false); elapsed=Math.floor(Math.random()*4000)+1200; moves=Math.floor(Math.random()*10)+2; timeEl.textContent=fmt(elapsed); movesEl.textContent=moves; finished=true; statusEl.textContent='Solved'; await saveScore({timeMs:Math.round(elapsed),moves,rows:ROWS,cols:COLS}); openMenu(); });
} else { devAddBtn.remove(); devSolveBtn.remove(); }

// Resize + menu background
function fitCanvas(){ const dpr=window.devicePixelRatio||1; const cardRect=document.getElementById('card').getBoundingClientRect(); const cRect=CANVAS.getBoundingClientRect(); CANVAS.width=Math.round(cRect.width*dpr); CANVAS.height=Math.round(cRect.height*dpr); CTX.setTransform(dpr,0,0,dpr,0,0); if(hasImage && !inMenu && pieces.length){ resizeBoardToImage(); draw(ghostOn); } menuBG.width=Math.round(cardRect.width*dpr); menuBG.height=Math.round(cardRect.height*dpr); menuBG.style.width=cardRect.width+'px'; menuBG.style.height=cardRect.height+'px'; mbgCtx.setTransform(dpr,0,0,dpr,0,0); }
const ro=new ResizeObserver(()=>fitCanvas()); ro.observe(document.getElementById('card')); setTimeout(()=>fitCanvas(),0);
window.addEventListener('keydown',(e)=>{ if(e.key.toLowerCase()==='p' && hasImage){ ghostOn=!ghostOn; draw(ghostOn);} });

openMenu();
let mobs=[], mouse={x:-9999,y:-9999}, bgAnim=false;
function initMenuBG(){ if(!dobbyLoaded) return; const N=40; mobs.length=0; const w=menuBG.width, h=menuBG.height; for(let i=0;i<N;i++){ const s=Math.random()*26+14; mobs.push({ x:Math.random()*w, y:Math.random()*h, vx:(Math.random()*2-1)*0.35, vy:(Math.random()*2-1)*0.35, size:s, rot:Math.random()*Math.PI*2 }); } if(!bgAnim){ bgAnim=true; requestAnimationFrame(tickBG);} }

// --- Share image & Tweet ---

function generateShare(){
  try{
    const sc=document.getElementById('shareCanvas'); const ctx=sc.getContext('2d');
    sc.width=800; sc.height=420;
    const W=sc.width, H=sc.height, pad=20;
    
    // Background
    ctx.fillStyle="#0b0f14";
    ctx.fillRect(0,0,W,H);

    // Layout
    const rightW = 340;
    const imgBox = { x: pad, y: pad, w: W - rightW - 2*pad, h: H - 2*pad };

    // Helper to draw rounded rectangle
    function roundRectPath(x,y,w,h,r=12){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.lineTo(x+w-r, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+r);
      ctx.lineTo(x+w, y+h-r);
      ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      ctx.lineTo(x+r, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-r);
      ctx.lineTo(x, y+r);
      ctx.quadraticCurveTo(x, y, x+r, y);
      ctx.closePath();
    }

    // White card under the image
    roundRectPath(imgBox.x, imgBox.y, imgBox.w, imgBox.h, 14);
    // No fill - transparent background
    
    // Clip to the rounded card so the image never shows background edges
    roundRectPath(imgBox.x, imgBox.y, imgBox.w, imgBox.h, 14);
    ctx.save();
    ctx.clip();

    // Draw the puzzle image with "cover" fit so it fully fills the box
    if(img && img.complete){
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const scale = Math.min(imgBox.w/iw, imgBox.h/ih);
      const dw = Math.ceil(iw * scale);
      const dh = Math.ceil(ih * scale);
      const dx = Math.floor(imgBox.x + (imgBox.w - dw)/2);
      const dy = Math.floor(imgBox.y + (imgBox.h - dh)/2);
      ctx.drawImage(img, dx, dy, dw, dh);
    } else {
      // Fallback placeholder
      ctx.fillStyle="#f2f2f2";
      ctx.fillRect(imgBox.x, imgBox.y, imgBox.w, imgBox.h);
      ctx.strokeStyle="#e0e0e0";
      for(let y=imgBox.y; y<imgBox.y+imgBox.h; y+=24){
        ctx.beginPath(); ctx.moveTo(imgBox.x, y); ctx.lineTo(imgBox.x+imgBox.w, y); ctx.stroke();
      }
      for(let x=imgBox.x; x<imgBox.x+imgBox.w; x+=24){
        ctx.beginPath(); ctx.moveTo(x, imgBox.y); ctx.lineTo(x, imgBox.y+imgBox.h); ctx.stroke();
      }
    }
    ctx.restore();

    // Right panel text
    const rX = W - pad - rightW + 6;
    const name=(getName()||"guest");

    ctx.fillStyle="#0b0f14"; // subtle shadow effect for legibility
    ctx.font="700 28px Inter, Arial"; ctx.fillText("PoKi Puzzle", rX+1, pad+31);
    ctx.fillStyle="#e8f0f7"; ctx.fillText("PoKi Puzzle", rX, pad+30);

    ctx.fillStyle="#e8f0f7"; ctx.font="800 18px Inter, Arial"; ctx.fillText("for @GoKiteAI", rX, pad+58);

    ctx.fillStyle="#9fb2c3"; ctx.font="600 14px Inter, Arial"; ctx.fillText("Player", rX, pad+118);
    ctx.fillStyle="#e8f0f7"; ctx.font="700 20px Inter, Arial"; ctx.fillText(name, rX, pad+140);

    ctx.fillStyle="#9fb2c3"; ctx.font="600 14px Inter, Arial"; ctx.fillText("Time", rX, pad+176);
    ctx.fillStyle="#e8f0f7"; ctx.font="700 20px Inter, Arial"; ctx.fillText(timeEl.textContent.trim(), rX, pad+198);

    ctx.fillStyle="#9fb2c3"; ctx.font="600 14px Inter, Arial"; ctx.fillText("Moves", rX, pad+234);
    ctx.fillStyle="#e8f0f7"; ctx.font="700 20px Inter, Arial"; ctx.fillText(moves.toString(), rX, pad+256);

    ctx.fillStyle="#9fb2c3"; ctx.font="500 14px Inter, Arial"; ctx.fillText("Try to beat my time â†’", rX, H-pad-56);
    ctx.fillStyle="#E6533C"; ctx.font="700 18px Inter, Arial"; ctx.fillText("crpbase.github.io/Dobby-Puzzle", rX, H-pad-28);

    document.getElementById('winOverlay').style.display='flex';
  }catch(e){ console.warn("generateShare error", e); }
}
document.getElementById('downloadShareBtn').addEventListener('click', ()=>{
  const sc=document.getElementById('shareCanvas'); const a=document.createElement('a');
  a.href=sc.toDataURL('image/png'); a.download='dobby-puzzle.png'; a.click();
});
document.getElementById('shareXBtn').addEventListener('click', ()=>{
  const timeTxt = document.getElementById('time').textContent.trim();
  const txt = [
    'PoKi Puzzle for @GoKiteAI',
    '',
    `I just solved the PoKi Puzzle by @crpbase in ${timeTxt}!`,
    '',
    'Try to beat my time: https://crpbase.github.io/PoKi-Puzzle/',
    '',
    '#ChallengePoKiPuzzle'
  ].join('\n');
  const url='https://twitter.com/intent/tweet?text='+encodeURIComponent(txt);
  window.open(url,'_blank');
});

// Observe status changes to detect finish
const statusObs=new MutationObserver(()=>{
  const t=statusEl.textContent.trim().toLowerCase();
  if(t.includes('solved') && document.getElementById('winOverlay').style.display!=='flex'){ window.__playVictory && window.__playVictory(); confettiBurst(); generateShare(); }
});
statusObs.observe(statusEl,{characterData:true,subtree:true,childList:true});


// OK -> back to main menu
document.getElementById('okBtn').addEventListener('click', ()=>{
  document.getElementById('winOverlay').style.display='none';
  openMenu();
});
// Ensure share UI hidden when opening menu
const _openMenu_orig = openMenu;
openMenu = function(){ document.body.classList.add('is-menu');
  const wo=document.getElementById('winOverlay'); if(wo) wo.style.display='none';
  _openMenu_orig();
};


try{ document.getElementById('startBtn').addEventListener('click',()=>{ try{ buildPieces(); }catch(_){} document.body.classList.remove('is-menu'); }); }catch(e){}// --- Nickname modal ---
const nameModal=document.getElementById('nameModal');
const nameInputModal=document.getElementById('nameInputModal');
function openNameModal(prefill=''){ nameModal.style.display='flex'; nameInputModal.value=prefill||getName()||''; setTimeout(()=>nameInputModal.focus(),0); }
function closeNameModal(){ nameModal.style.display='none'; }
document.getElementById('changeNameBtn').addEventListener('click', ()=>openNameModal());
document.getElementById('saveNameModal').addEventListener('click', ()=>{ const v=(nameInputModal.value||'').trim().slice(0,24); localStorage.setItem(nameKey,v); closeNameModal(); });
document.getElementById('skipNameModal').addEventListener('click', ()=>closeNameModal());

// First run: show modal once if no name saved
if(!(getName()||'').trim()){ setTimeout(()=>openNameModal(), 300); }

// Disable Shuffle until image loads
shuffleBtn.disabled = true;

function tickBG(){ if(!inMenu){ bgAnim=false; return; } mbgCtx.clearRect(0,0,menuBG.width,menuBG.height); const w=menuBG.width, h=menuBG.height; for(const m of mobs){ m.vx+=(Math.random()*2-1)*0.02; m.vy+=(Math.random()*2-1)*0.02; const scaleX=menuBG.width/menuBG.clientWidth, scaleY=menuBG.height/menuBG.clientHeight; const mx=mouse.x*scaleX, my=mouse.y*scaleY; const dx=m.x-mx, dy=m.y-my; const R=130, R2=R*R, d2=dx*dx+dy*dy; if(d2<R2){ const f=(R2-d2)/R2, ang=Math.atan2(dy,dx); m.vx+=Math.cos(ang)*f*1.2; m.vy+=Math.sin(ang)*f*1.2;} const sp=Math.hypot(m.vx,m.vy), max=1.6; if(sp>max){ m.vx=m.vx/sp*max; m.vy=m.vy/sp*max;} m.vx*=0.995; m.vy*=0.995; m.x+=m.vx; m.y+=m.vy; if(m.x<-60)m.x=w+60; if(m.x>w+60)m.x=-60; if(m.y<-60)m.y=h+60; if(m.y>h+60)m.y=-60; const sz=m.size; mbgCtx.save(); mbgCtx.translate(m.x,m.y); mbgCtx.rotate(m.rot); mbgCtx.globalAlpha=0.78; mbgCtx.drawImage(dobby,-sz/2,-sz/2,sz,sz); mbgCtx.restore(); } requestAnimationFrame(tickBG); }
menuOverlay.addEventListener('mousemove', (e)=>{ const r=menuOverlay.getBoundingClientRect(); mouse.x=e.clientX-r.left; mouse.y=e.clientY-r.top; });
menuOverlay.addEventListener('mouseleave', ()=>{ mouse.x=-9999; mouse.y=-9999; });

// --- SFX ---
(function(){
  const sndClick = document.getElementById('sndClick');
  const sndSnap  = document.getElementById('sndSnap');
  function playSfx(a){ try{ if(!a) return; a.currentTime = 0; a.play(); }catch(e){} }
  // Click on any button -> click sound
  document.addEventListener('click', function(ev){
    const btn = ev.target.closest && ev.target.closest('button');
    if(btn) playSfx(sndClick);
  }, true);
  // Keyboard activation for buttons
  document.addEventListener('keydown', function(ev){
    if((ev.key === 'Enter' || ev.key === ' ') && document.activeElement && document.activeElement.tagName === 'BUTTON'){
      playSfx(sndClick);
    }
  }, true);
  // Expose for game logic
  window.__playSnap = function(){ playSfx(sndSnap); };
})();


// Victory SFX
(function(){
  var a=document.getElementById('sndVictory');
  window.__playVictory=function(){ try{ if(a){ a.currentTime=0; a.play(); } }catch(e){} };
})();

// Auto-shuffle on game start/reset so replay doesn't require pressing Shuffle
(function(){
  try{
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const okBtn = document.getElementById('okBtn');
    function autoShuffleSoon(delay){
      setTimeout(()=>{
        try{
          if(typeof buildPieces==='function' && window.hasImage) buildPieces();
        }catch(e){}
        if(shuffleBtn) shuffleBtn.click();
      }, delay||60);
    }
    if(startBtn && shuffleBtn){
      startBtn.addEventListener('click', ()=> autoShuffleSoon(80), true);
    }
    if(resetBtn && shuffleBtn){
      resetBtn.addEventListener('click', ()=> autoShuffleSoon(40), true);
    }
    if(okBtn && shuffleBtn){
      okBtn.addEventListener('click', ()=> {
        // after closing win overlay and going to menu, next Start will also auto-shuffle
        // nothing else here
      }, true);
    }
  }catch(e){}
})();

</script>

  <!-- Nickname Modal -->
  <div class="modal" id="nameModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:100;align-items:center;justify-content:center">
    <div class="card" style="max-width:min(92vw,420px);border-radius:16px;border:1px solid var(--line)">
      <div class="wrap" style="padding:18px">
        <h2 style="margin:0 0 10px 0">Choose your nickname</h2>
        <p style="margin:6px 0 12px;color:#6f6f6f">We'll show it on the leaderboard and on your share image. You can change it later.</p>
        <input type="text" id="nameInputModal" placeholder="Your nickname" maxlength="24" style="width:100%;border:1px solid var(--line);border-radius:12px;padding:12px 14px;font:inherit">
        <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
          <button class="btn" id="skipNameModal">Skip</button>
          <button class="btn primary" id="saveNameModal">Save</button>
        </div>
      </div>
    </div>
  </div>

<script id="patch_menu_final_v16_js">
(function(){
  try{
    var overlay = document.getElementById('menuOverlay');
    var menuBG  = document.getElementById('menuBG');
    if(!overlay || !menuBG) return;
    var mbgCtx = menuBG.getContext('2d');

    function sizeMenuBGToOverlay(){
      var dpr = window.devicePixelRatio || 1;
      var r = overlay.getBoundingClientRect();
      menuBG.width  = Math.max(1, Math.round(r.width  * dpr));
      menuBG.height = Math.max(1, Math.round(r.height * dpr));
      menuBG.style.width  = r.width  + 'px';
      menuBG.style.height = r.height + 'px';
      mbgCtx.setTransform(dpr,0,0,dpr,0,0);
    }

    function restartMenuBackground(){
      try{ sizeMenuBGToOverlay(); }catch(_){}
      try{ if(typeof initMenuBG === 'function') initMenuBG(); }catch(_){}
      try{ if(typeof tickBG === 'function'){ window.bgAnim = true; requestAnimationFrame(tickBG); } }catch(_){}
    }

    // Hook openMenu so sizing happens immediately after entering the menu
    if(typeof window.openMenu === 'function' && !window.openMenu.__v16){
      var _orig = window.openMenu;
      window.openMenu = function(){
        var res = _orig.apply(this, arguments);
        // Make overlay transparent and restart bg
        try{ overlay.style.background = 'transparent'; }catch(_){}
        setTimeout(restartMenuBackground, 0);
        return res;
      };
      window.openMenu.__v16 = true;
    }

    // Keep sizing correct on resize while in menu
    window.addEventListener('resize', function(){
      if(document.body.classList.contains('is-menu')) sizeMenuBGToOverlay();
    });

    // If the page already is in menu on load
    if(document.body.classList.contains('is-menu')){
      overlay.style.background = 'transparent';
      restartMenuBackground();
    }
  }catch(e){ console.warn('v16 patch failed', e); }
})();
</script>


  <audio id="sndClick" src="but.mp3" preload="auto"></audio>
  <audio id="sndSnap" src="puzzle.mp3" preload="auto"></audio>

  <audio id="sndVictory" src="victory.mp3" preload="auto"></audio>

<script id="follow_dock_script_right">
(function(){
  function mkBtn(text, href){
    var a = document.createElement('a');
    a.className = 'btn primary follow-sm';
    a.textContent = text;
    a.href = href;
    a.target = '_blank';
    a.rel = 'noopener noreferrer';
    return a;
  }
  function mkDock(){
    var dock = document.createElement('div');
    dock.className = 'followDock';
    dock.appendChild(mkBtn('Follow crpbase','https://x.com/CrpBase'));
    dock.appendChild(mkBtn('Follow Katun','https://x.com/KatuntheOG'));
    return dock;
  }
  function sizeButtons(){
    var start = document.getElementById('startBtn');
    var width = start ? start.getBoundingClientRect().width : 280;
    var target = Math.round(width * 0.7);
    document.querySelectorAll('.followDock .btn').forEach(function(b){
      b.style.minWidth = target + 'px';
      b.style.maxWidth = target + 'px';
      b.style.textAlign = 'center';
    });
  }
  function init(){
    if(!document.querySelector('.followDock')){
      document.body.appendChild(mkDock());
    }
    sizeButtons();
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, {once:true});
  }else{
    init();
  }
  window.addEventListener('resize', sizeButtons);
})();
</script>



<script id="sentient_magic_js">
(function(){
  // Pointer sheen on buttons - update --mx for highlight position
  document.addEventListener('mousemove', function(e){
    const t = e.target.closest('.btn');
    if(!t) return;
    const r = t.getBoundingClientRect();
    const mx = ((e.clientX - r.left) / Math.max(1,r.width)) * 100;
    t.style.setProperty('--mx', mx + '%');
  }, {passive:true});

  // Ripple effect in accent color
  function ripple(ev){
    const b = ev.currentTarget || ev.target;
    const r = b.getBoundingClientRect();
    const s = document.createElement('span');
    s.style.position='absolute'; s.style.borderRadius='999px';
    s.style.pointerEvents='none'; s.style.left=(ev.clientX-r.left-10)+'px'; s.style.top=(ev.clientY-r.top-10)+'px';
    s.style.width='20px'; s.style.height='20px';
    s.style.background='radial-gradient(circle, rgba(255,255,255,0.7) 0%, rgba(230,83,60,0.35) 30%, rgba(230,83,60,0.0) 70%)';
    s.style.transform='scale(0)'; s.style.opacity='0.9';
    s.style.transition='transform .6s ease-out, opacity .6s ease-out';
    b.appendChild(s);
    requestAnimationFrame(()=>{ s.style.transform='scale(12)'; s.style.opacity='0'; });
    setTimeout(()=>s.remove(), 650);
  }
  document.addEventListener('click', function(e){
    const t=e.target.closest('.btn'); if(t) ripple({target:t, clientX:e.clientX, clientY:e.clientY});
  });

  // Pulse Start and Follow buttons
  function addPulse(){
    const start = document.getElementById('startBtn');
    if(start) start.classList.add('magicPulse');
    document.querySelectorAll('.followDock .btn').forEach(b=>b.classList.add('magicPulse'));
  }

  // Dobby sprites floating during gameplay instead of red dots
  function spawnDobbySprites(){
    const layer = document.createElement('canvas'); layer.width=innerWidth; layer.height=innerHeight;
    layer.style.position='fixed'; layer.style.inset='0'; layer.style.pointerEvents='none';
    layer.style.zIndex='0'; layer.id='dobbyLayer';
    document.body.appendChild(layer);
    const ctx = layer.getContext('2d');

    const img = new Image();
    img.src = 'dobby.png';

    let sprites = [];
    function initSprites(){
      const count = 60;
      sprites = Array.from({length:count}).map(()=>{
        const s = (Math.random()*12 + 10); // 10-22px
        const speed = 0.15 + Math.random()*0.35;
        return {
          x: Math.random()*layer.width,
          y: Math.random()*layer.height,
          vx: (Math.random()<0.5?-1:1) * speed,
          vy: (-0.25 - Math.random()*0.45), // drift upward
          size: s,
          r: Math.random()*Math.PI*2,
          rv: (Math.random()-0.5)*0.01
        };
      });
    }

    function updateVisibility(){ const inMenu = document.body.classList.contains('is-menu'); layer.style.display = inMenu ? 'block' : 'none'; }

    function tick(){
      updateVisibility();
      ctx.clearRect(0,0,layer.width,layer.height);
      if(img.complete && img.naturalWidth){
        for(const p of sprites){
          p.x += p.vx; p.y += p.vy; p.r += p.rv;
          if(p.y < -30){ p.y = layer.height + 30; p.x = Math.random()*layer.width; }
          if(p.x < -30) p.x = layer.width + 30;
          if(p.x > layer.width + 30) p.x = -30;
          ctx.save();
          ctx.globalAlpha = 0.75;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.r);
          ctx.drawImage(img, -p.size/2, -p.size/2, p.size, p.size);
          ctx.restore();
        }
      }
      requestAnimationFrame(tick);
    }

    initSprites();
    tick();
    window.addEventListener('resize', ()=>{ layer.width=innerWidth; layer.height=innerHeight; initSprites(); });
  }

  function init(){ addPulse(); spawnDobbySprites(); }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init, {once:true}); }
  else{ init(); }
})();
</script>



<script id="fit-board-script">
(function(){
  function fit(){
    var board = document.querySelector('.board');
    if(!board) return;
    // reset to natural height to measure correctly
    board.style.height = 'auto';
    var rect = board.getBoundingClientRect();
    var cs = window.getComputedStyle(board);
    var mb = parseFloat(cs.marginBottom)||0;
    var gap = 8;
    var avail = Math.max(320, Math.floor(window.innerHeight - rect.top - mb - gap));
    board.style.height = avail + 'px';
    var cvs = board.querySelector('canvas#canvas') || board.querySelector('.canvas') || board.querySelector('canvas');
    if(cvs){ cvs.style.width='100%'; cvs.style.height='100%'; }
    var dock = document.querySelector('.followDock');
    if(dock){ dock.style.display='none'; }
  }
  window.addEventListener('resize', fit, {passive:true});
  window.addEventListener('orientationchange', fit);
  document.addEventListener('DOMContentLoaded', fit);
  window.addEventListener('load', function(){ fit(); setTimeout(fit, 250); setTimeout(fit, 1000);} );
})();
</script>
</body>
</html>
